# 我的mv*理解，mvc|mvp|mvvm





在网上看mvc是苹果最新提出来的，典型应用我理解大概是Cocoa中的NSTableView吧。勉强记得是数据变化后，是需要reload重新载入。所以一开始就需要绑定住模型和视图的关系。我粗略地想象DataSource是建立视图和数据源的映射关系，Delegate是建立视图动作的响应。但是面向对象表达能力太让人纠结，比如多个tableView在同一个类里的配置就混杂起来。我更倾向于面向接口式的编程，像jQuery函数调用式地传递一个复杂的配置参数。而且我当时也纠结另一个问题：最注重动画效果的苹果在reload时怎么区别新的和旧的，只对改变条目触发动画更符合人的直觉。



后来接触web，才渐渐明白编程领域绝大部分都是在围绕着web转。web里有mvc，也就是后端mvc：服务器响应的时候用最新的数据渲染配置的页面模板返回给浏览器，浏览器仅仅充当渲染引擎，很多后端不喜欢弱类型的js，甚至以无js网站为傲。但接触ajax后，我发现ajax多节省！如果仅仅是全局重渲染，如何精细地记住用户的操作呢？是不是每次滚动、每次敲打文字都要后端渲染呢？当然也有一些后端mvc引擎做出了适配这种需求的奇技淫巧。



我本人是很喜欢js的，我认为编程语言就是便利人的使用（而不是一味高性能），js有灵活的匿名函数与Array/Object构造。虽说是弱类型，但也可比python/ruby好啊——有了ts之后就更加坚定了。在全栈时期我就很喜欢将一些无关逻辑移到前端去。果然后来前端大爆发。尽管我也有很多个人的偏执没能加入这场大潮流。



前端也有很多mvc，不一一举例了，最简单的是将模板渲染移到前端，更微细成组件单位。我认为react就是这种mvc，只是通过设计将渲染变成更自动化，程序员关注得更少。另一种mvc我理解是传统的桌面gui编程（如Cocoa），将成员组件/成员组件事件拦截下来，然后手写代码关联：事件动作修改模型/修改成员组件的表现形式(如文字内容、颜色)。我一直以为后一种就是正常的mvc——至少它是有组件复用的。不像传统的jQuery全局筛来筛去，总害怕名字上冲突了（明明有那么优秀的js语言加持！）。



mvp，道听途说的理解，比如数据表格，原生没有（不符合原生精核的要义），实现上困难，但使用现成的，只在参数上按文档配置一下就可以了。这么说NSTableView也有点mvp的味道。



我一直觉得界面元素都是有生命的，明明自己也要作响应事件这样的事，单单作界面渲染的语法太不尊重人家了。所以mvvm比较符合我的想象，它应该是第二种mvc的进阶。但具体怎么实现呢？源头的WPF——我真不喜欢面向对象和XML/XAML，VS这一套卡顿工具也使我对它的印像大打折扣。浏览器领域也有一些mvvm框架，比如经典的KnockoutJS——好吧，打铁还需要自身硬，除非自己理解来龙去脉，别人无法帮助你。mvvm想象轻松，但实现观察与注销本身很需要考量。当我渐渐掌握js的开发方式的时候，便在思索如何运用强大的js精巧地设计出一套自己的mvvm框架。



我曾用js实现了类似传统桌面编程的“mvc”，正是使用js强大的Array/Object构造实现DSL布局，而不用难理解的XML。而且使用匿名函数直接挂载在事件上，使用id将局部的成员组件取回来待修改。比传统桌面编程也高效不少，主要是DOM本身布局语法的深入人心。vue出现后，给我进一步启发：界面编程，最复杂的其实是状态同步，通常1个模型影响多个界面属性，更有1个界面属性受多个模型影响：这在逻辑上确实是必要的，再一一用代码去关联，很容易遗漏。vue实现了，看各种网文介绍用了一种新颖的依赖统计方法。但是自己的工作离不开兼容IE8，而当时vue一定要IE9以上，原因是说需要用到ES5的defineProperty属性——本来我就不喜欢C#里这种偷偷摸摸将字段访问变成动作的行为。本着使用匿名函数是万能的——我想我能提炼出最精核的vue。但阅读vue对我还是太难了(大项目通常考虑甚多)，我也不太喜欢vue这种object式的组件。学习vue的依赖统计，还是依赖很多别人的二手消化资料。



感觉自己一直都是这种小手小脚地节约dom，太重视界面元素，步子放不开，是不是不能像别人一样有效提高开发效率。现在看来，像react，仍然类似后端mvc，在逻辑层面多直观！但当时react也是面向对象的。而且react确实也出了些性能问题。仅仅是单组件层面，属性到模型的绑定，使用vue的依赖统计还是挺成功的，每次变更只通知属性调整。但一直也没法进一步深入到整体：网页可能是很复杂的，像导航、弹窗更是函数式的，如何与mvvm无缝关联？最要命的还是列表（map也可以转化成某种顺序的列表），如NSTableView，难道每次都要清空重建？说好的精确到具体增删的元素呢？我一直以为vue是解决了这个问题的。因为react的清空重建，或者缓存对比更新，本质上仍然是mvc模式了。



话说到这里，总结一下我对mvc/mvvm的理解：后者的关键就是对界面元素的尊重，模型变更是通知元素属性更新而非重建。如果只将界面元素当作布局语法，就是mvc。react是mvc，vue是mvvm+mvc（列表部分）。从原初需要手动定制界面的更新逻辑，mv*实现布局绑定后自动更新界面。



导航其实也经历过两种，一种是浏览器的导航，只与url相关，虽然前进是覆盖，回退是重新加载之前的url——本地有缓存——那就只需要建立一个全局的特殊处理就好。还有一种是iOS的导航，将历史层叠在后面，回退的时候只需将当前页弹出销毁。其实很像一层一层的弹窗，只是弹窗全屏彼此覆盖——这么看来导航算是一种列表。

弹窗也有两种，一种像上面说的层层相叠。另一种是只允许一个弹窗。如果用函数来封装就是只允许存储一个值的设置。只是还有一点，复用性——每次都新建元素吗？其实只是建立模型的维度。

列表模型怎么建？像NSTableView可以自定义Cell。但现实中也有特例，比如在列表布局中，某个元素需要占用两行或N行——不然都不比传统界面编程强大。

